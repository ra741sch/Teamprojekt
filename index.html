<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>GPS Tracker mit Umschaltbutton</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .button {
      position: absolute;
      top: 10px;
      padding: 10px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      z-index: 1000;
    }
    #startBtn { left: 10px; }
    #backBtn { left: 140px; background-color: #dc3545; }
    #toggleBtn { left: 270px; background-color: orange; }

    #infoBox {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 8px 12px;
      font-family: sans-serif;
      font-size: 14px;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: right;
      min-width: 160px;
      line-height: 1.3em;
    }
  </style>
</head>
<body>
  <button id="startBtn" class="button">üìç Start Tracking</button>
  <button id="backBtn" class="button">üîô Zur√ºck</button>
  <button id="toggleBtn" class="button">‚è∏Ô∏è Pause</button>
  <div id="infoBox">
    ‚è±Ô∏è Letztes Update: ‚Äì<br>
    üöÄ Geschwindigkeit: ‚Äì<br>
    üß≠ Gesamtstrecke: ‚Äì<br>
    üìè Reststrecke: ‚Äì<br>
    ‚úÖ Zur√ºckgelegt: ‚Äì<br>
    ‚è≥ Timer: 05:00.000
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <script>
    // Karte initialisieren (mit Default View, wird sp√§ter durch Standort √ºberschrieben)
   const map = L.map('map').setView([47.7, 9.0], 17); 
 const satellite = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Tiles ¬© Esri'
});

const labels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Labels ¬© Esri'
});

L.layerGroup([satellite, labels]).addTo(map);


    // Beim Laden einmal aktuellen Standort holen und Karte dahin zentrieren
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          map.setView([lat, lng], 17);  // Zoom bleibt 17
        },
        (err) => {
          console.warn("Standort konnte nicht ermittelt werden, Karte bleibt auf Default.");
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    } else {
      console.warn("Geolocation wird nicht unterst√ºtzt, Karte bleibt auf Default.");
    }

    // Globale Variablen
    const routePoints = [];
    const pointMarkers = [];
    let polyline = null;
    let turfLine = null;
    let trackingStarted = false;

    let lastUpdateTime = null;
    let currentSpeed = null;
    let gpsWatcher = null;
    let gpsPaused = false;

    let distanceToGoal = null;
    let distanceCovered = 0;

    let countdownDuration = 5 * 60 * 1000; // 5 Minuten in ms
    let countdownStart = null;
    let countdownInterval = null;

    let averageSpeed = 0; // m/s
let lapCountEstimate = 0;
let suggestedSpeedLower = null;
let suggestedSpeedUpper = null;


    const infoBox = document.getElementById("infoBox");
    const toggleBtn = document.getElementById("toggleBtn");

    // Timer Anzeige in infoBox separat updaten
    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const milliseconds = ms % 1000;

      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(milliseconds).padStart(3,'0')}`;
    }

    function updateInfoBoxTime(remainingMs) {
      const timeStr = formatTime(Math.max(remainingMs, 0));
      // Timer immer als letzte Zeile hinzuf√ºgen
      infoBox.innerHTML = infoBox.innerHTML.replace(/‚è≥ Timer: .*$/m, `‚è≥ Timer: ${timeStr}`);
    }

    function startCountdown() {
      countdownStart = Date.now();
      if (countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(() => {
        const elapsed = Date.now() - countdownStart;
        const remaining = countdownDuration - elapsed;

        if (remaining <= 0) {
          clearInterval(countdownInterval);
          updateInfoBoxTime(0);
        } else {
          updateInfoBoxTime(remaining);
        }
      }, 50);
    }

    // InfoBox mit allen Werten aktualisieren (au√üer Timer, der l√§uft separat)
    function updateInfoBox() {
  let timeText = "‚è±Ô∏è Letztes Update: ‚Äì";
  let speedText = "üöÄ Geschwindigkeit: ‚Äì";
  let restDistText = "üìè Reststrecke: ‚Äì";
  let coveredDistText = "‚úÖ Zur√ºckgelegt: ‚Äì";
  let totalDistText = "üß≠ Gesamtstrecke: ‚Äì";
  let avgSpeedText = "üìà √ò-Tempo: ‚Äì";
  let suggSpeedText = "üéØ Ziel: ‚Äì / ‚Äì";

  if (lastUpdateTime) {
    const delta = Date.now() - lastUpdateTime;
    timeText = `‚è±Ô∏è Letztes Update: ${(delta / 1000).toFixed(2)} s`;
  }
  if (currentSpeed !== null) {
    const kmh = (currentSpeed * 3.6).toFixed(1);
    speedText = `üöÄ Geschwindigkeit: ${kmh} km/h`;
  }
  if (distanceToGoal !== null) {
    restDistText = `üìè Reststrecke: ${distanceToGoal.toFixed(1)} m`;
  }
  if (distanceCovered !== null) {
    coveredDistText = `‚úÖ Zur√ºckgelegt: ${distanceCovered.toFixed(1)} m`;
  }
  if (typeof totalDistance === "number") {
    totalDistText = `üß≠ Gesamtstrecke: ${totalDistance.toFixed(1)} m`;
  }

  const elapsed = countdownStart ? (Date.now() - countdownStart) / 1000 : 0;
  if (elapsed > 0 && distanceCovered > 0) {
    averageSpeed = distanceCovered / elapsed; // m/s
    const kmh = (averageSpeed * 3.6).toFixed(1);
    avgSpeedText = `üìà √ò-Tempo: ${kmh} km/h`;

    const remainingTime = (countdownDuration - (Date.now() - countdownStart)) / 1000;
    const lapLength = totalDistance;
    if (lapLength > 0 && remainingTime > 0) {
      lapCountEstimate = (averageSpeed * remainingTime) / lapLength;

      const lowerTarget = Math.floor(lapCountEstimate);
      const upperTarget = lowerTarget + 1;

      const speedLower = (lapLength * lowerTarget) / remainingTime;
      const speedUpper = (lapLength * upperTarget) / remainingTime;

      suggestedSpeedLower = (speedLower * 3.6).toFixed(1);
      suggestedSpeedUpper = (speedUpper * 3.6).toFixed(1);

      suggSpeedText = `üéØ Ziel: ${suggestedSpeedLower} ‚Üì / ${suggestedSpeedUpper} ‚Üë km/h`;
    }
  }

  const timerLine = infoBox.innerHTML.match(/‚è≥ Timer: .*/);
  infoBox.innerHTML = `${timeText}<br>${speedText}<br>${avgSpeedText}<br>${restDistText}<br>${coveredDistText}<br>${totalDistText}<br>${suggSpeedText}<br>` + (timerLine ? timerLine[0] : `‚è≥ Timer: 05:00.000`);
}


    // Update InfoBox regelm√§√üig
    setInterval(updateInfoBox, 200);

    // Strecke zeichnen und Punkte setzen
    map.on('click', function(e) {
      if (trackingStarted) return; // Keine Punkte w√§hrend Tracking setzen

      const latlng = [e.latlng.lat, e.latlng.lng];
      routePoints.push(latlng);

      // Erster Punkt magenta, alle anderen blau
      const markerColor = routePoints.length === 1 ? 'magenta' : 'blue';
      const marker = L.circleMarker(latlng, { radius: 5, color: markerColor }).addTo(map);
      pointMarkers.push(marker);

      updateDistance();
      drawPolyline();
    });

    function drawPolyline() {
      if (polyline) map.removeLayer(polyline);
      if (routePoints.length >= 2) {
        polyline = L.polyline(routePoints, { color: 'blue' }).addTo(map);
      }
    }

    function updateDistance() {
      totalDistance = 0;
      if (routePoints.length >= 2) {
        for (let i = 1; i < routePoints.length; i++) {
          const from = turf.point([routePoints[i - 1][1], routePoints[i - 1][0]]);
          const to = turf.point([routePoints[i][1], routePoints[i][0]]);
          totalDistance += turf.distance(from, to, { units: 'meters' });
        }
      }
    }

    // "Zur√ºck"-Button - letzter Punkt l√∂schen
    document.getElementById("backBtn").addEventListener("click", () => {
      if (trackingStarted || routePoints.length === 0) return;

      routePoints.pop();
      const lastMarker = pointMarkers.pop();
      if (lastMarker) map.removeLayer(lastMarker);

      updateDistance();
      drawPolyline();
    });

    // "Start Tracking"-Button
    document.getElementById("startBtn").addEventListener("click", () => {
      if (routePoints.length < 2) {
        alert("Bitte zuerst eine Strecke zeichnen!");
        return;
      }

      // Strecke schlie√üen (Start = Ziel), falls noch nicht
      if (!routePoints[0].every((val, index) => val === routePoints[routePoints.length - 1][index])) {
        routePoints.push(routePoints[0]);
      }

      updateDistance();
      drawPolyline();

      trackingStarted = true;
      document.getElementById("startBtn").disabled = true;
      document.getElementById("backBtn").disabled = true;

      turfLine = turf.lineString(routePoints.map(p => [p[1], p[0]]));

      distanceCovered = 0;
      distanceToGoal = totalDistance;

      startLiveGPS();
      startCountdown();
    });

    // Umschaltbutton Pause / Weiter
    toggleBtn.addEventListener("click", () => {
      if (!trackingStarted) return;

      if (!gpsPaused) {
        // pausieren
        if (gpsWatcher !== null) {
          navigator.geolocation.clearWatch(gpsWatcher);
          gpsWatcher = null;
        }
        gpsPaused = true;
        toggleBtn.innerText = "‚ñ∂Ô∏è Weiter";
        toggleBtn.style.backgroundColor = "green";
      } else {
        // weiter
        startLiveGPS();
        gpsPaused = false;
        toggleBtn.innerText = "‚è∏Ô∏è Pause";
        toggleBtn.style.backgroundColor = "orange";
      }
    });

    // GPS Live Tracking
    function startLiveGPS() {
      if (!navigator.geolocation) {
        alert("GPS wird nicht unterst√ºtzt.");
        return;
      }

      gpsWatcher = navigator.geolocation.watchPosition(
        pos => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const speed = pos.coords.speed;

          lastUpdateTime = Date.now();
          currentSpeed = speed !== null ? speed : null;

          const currentPoint = turf.point([lng, lat]);
          const snapped = turf.nearestPointOnLine(turfLine, currentPoint);

          const snappedLatLng = [snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]];

          // Entferne bisherige rote Marker
          pointMarkers.forEach(m => {
            if (m.options.color === 'red') map.removeLayer(m);
          });

          // Neuen roten Marker setzen (n√§chster Punkt auf Strecke)
          const redMarker = L.circleMarker(snappedLatLng, { color: 'red', radius: 6 }).addTo(map);
          pointMarkers.push(redMarker);

          // Gelben Marker f√ºr aktuelle GPS-Position setzen (klein)
          const gpsMarker = L.circleMarker([lat, lng], { color: 'yellow', radius: 4 }).addTo(map);
          pointMarkers.push(gpsMarker);

          // N√§chstgelegenen Index auf Strecke finden
          let nearestIndex = 0;
          let minDist = Infinity;
          for (let i = 0; i < routePoints.length; i++) {
            const pt = routePoints[i];
            const dist = turf.distance(
              turf.point([pt[1], pt[0]]),
              turf.point([snapped.geometry.coordinates[0], snapped.geometry.coordinates[1]]),
              { units: 'meters' }
            );
            if (dist < minDist) {
              minDist = dist;
              nearestIndex = i;
            }
          }

          // Berechne Reststrecke von n√§chstem Punkt bis Start (Index 0) entlang der Strecke (geschlossen)
          let remainingDist = 0;
          const n = routePoints.length;
          for (let i = nearestIndex; i != 0; i = (i + 1) % n) {
            const current = turf.point([routePoints[i][1], routePoints[i][0]]);
            const next = turf.point([routePoints[(i + 1) % n][1], routePoints[(i + 1) % n][0]]);
            remainingDist += turf.distance(current, next, { units: 'meters' });
          }
          distanceToGoal = remainingDist;

          // Berechne zur√ºckgelegte Strecke (total - rest)
          distanceCovered = totalDistance - distanceToGoal;

          // Karte zentrieren
          map.setView([lat, lng]);

        },
        err => {
          alert("GPS-Fehler: " + err.message);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 5000
        }
      );
    }
  </script>
</body>
</html>
